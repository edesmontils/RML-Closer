@prefix log: <http://www.w3.org/2000/10/swap/log#>.@prefix str: <http://www.w3.org/2000/10/swap/string#>.@prefix owl: <http://www.w3.org/2002/07/owl#>.@prefix xsd: <http://www.w3.org/2001/XMLSchema#>.@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.@prefix rr: <http://www.w3.org/ns/r2rml#> .@prefix rml: <http://semweb.mmlab.be/ns/rml#> .@prefix ql: <http://semweb.mmlab.be/ns/ql#> .@prefix : <http://github.com/edesmontils/RML-Closer#> .# ===========================================================================================# Gestion des concepts# ===========================================================================================# ===========================================================================================# transitivité sur rdfs:subClassOf[ (:cpt :val ?val) (?m rr:subjectMap ?s) (?s rr:class ?C) (?C rdfs:subClassOf ?D)  noValue(?s rr:class ?D)addOne(?val,?w)-> remove(0) (:cpt :val ?w)(?s rr:class ?D)]# ===========================================================================================# sameAs : #{ ?s a ?C . ?C owl:sameAs ?D . } => { ?s a ?D .} .[ (?m rr:subjectMap ?s) (?s rr:class ?C) (?C owl:sameAs ?D)  noValue(?s rr:class ?D)-> (?s rr:class ?D)]#{ ?s ?p ?o . ?s owl:sameAs ?x . } => { ?x ?p ?o .} .# TODO ? pas possible, il faudrait avoir des sameAs dans le données. Si oui... a faire avec la query#{ ?s ?p ?o . ?o owl:sameAs ?x . } => { ?s ?p ?x .} .# TODO ? pas possible, il faudrait avoir des sameAs dans le données. Si oui... a faire avec la query# ===========================================================================================# equivalentClass#{ ?x a ?class . ?class owl:equivalentClass ?equiv . } #	=> { ?x a ?equiv . } .[(?m rr:subjectMap ?s) (?s rr:class ?C) (?C owl:equivalentClass ?D) noValue(?s rr:class ?D)-> (?s rr:class ?D)]# ===========================================================================================# Gestion des relations# ===========================================================================================# ===========================================================================================# Transitivité du rdfs:subPropertyOf[(?m rr:predicateObjectMap ?s) (?s rr:predicate ?p) (?p rdfs:subPropertyOf ?q) noValue(?s rr:predicate ?q)-> (?s rr:predicate ?q)]# ===========================================================================================# Domains#{ ?x ?pred ?y . ?pred rdfs:domain ?c . } #	=> { ?x a ?c . } .[(?m rr:predicateObjectMap ?s) (?s rr:predicate ?p) (?m rr:subjectMap ?t)(?p rdfs:domain ?c) noValue(?t rr:class ?c)-> (?t rr:class ?c)]# ===========================================================================================# Ranges#{ ?x ?pred ?y . ?pred rdfs:range ?c . } #	=> { ?y a ?c . } .[(?m rr:predicateObjectMap ?po) (?po rr:predicate ?p) (?p rdfs:range ?C)(?po rr:objectMap ?o) (?o rr:parentTriplesMap ?m2)(?m2 rr:subjectMap ?s)  noValue(?s rr:class ?C)->(?s rr:class ?C)]# A vérifier ! #(:cpt :val ?v) addOne(?v,?w)#remove(0) (:cpt :val ?w)[ (?m rr:predicateObjectMap ?po) (?po rr:predicate ?p) (?p rdfs:range ?C)(?m rml:logicalSource ?ls)(?po rr:objectMap ?o) (?o rr:template ?t) makeTemp(?m2) makeTemp(?x)-> (?m2 rml:logicalSource ?ls)(?m2 rr:subjectMap ?x)(?x rr:class ?C)(?x rr:template ?t)]# ===========================================================================================# sameAs : { ?s ?p ?o . ?p owl:sameAs ?x . } => { ?s ?x ?o .} .[(?m rr:predicateObjectMap ?s) (?s rr:predicate ?p) (?p owl:sameAs ?q)  noValue(?s rr:predicate ?q)-> (?s rr:predicate ?q)]# ===========================================================================================# equivalentProperty#{ ?x ?pred ?y . ?pred owl:equivalentProperty ?equiv . } #	=> { ?x ?equiv ?y . } .[(?m rr:predicateObjectMap ?s) (?s rr:predicate ?p) (?p owl:equivalentProperty ?q) noValue(?s rr:predicate ?q) -> (?s rr:predicate ?q)]# ===========================================================================================# Gestion des caractéristiques des propriétés# ===========================================================================================# {?P owl:inverseOf ?Q. ?S ?P ?O} => {?O ?Q ?S}.## Inverses.#{ ?x owl:inverseOf ?y . } #	=> { ?x a owl:Property . ?y a owl:Property . } .#{ ?x ?pred ?y . ?pred owl:inverseOf ?inverse . } #	=> { ?y ?inverse ?x . } .# {?P a owl:SymmetricProperty. ?S ?P ?O} => {?O ?P ?S}.## Symmetric properties#{ ?pred a owl:SymmetricProperty . } #	=> { ?pred a owl:Property . } .#{ ?pred a owl:SymmetricProperty . ?x ?pred ?y . } #	=> { ?y ?pred ?x .} .# Transitive prop. : pas gérable à ce niveau ! # Devrait être fait lors de la construction de la requête interne (TP2Query) ou après...# {?P a owl:TransitiveProperty. ?X ?P ?O. ?S ?P ?X} => {?S ?P ?O}.## Transitive properties#{ ?pred a owl:TransitiveProperty . } #	=> { ?pred a owl:Property . } .#{ ?pred a owl:TransitiveProperty . ?x ?pred ?y . ?y ?pred ?z . } #	=> { ?x ?pred ?z .} .# Functional Properties#{ ?pred a owl:FunctionalProperty . } #	=> { ?pred a owl:Property . } .#{ ?pred a owl:FunctionalProperty . ?x ?pred ?y . ?x ?pred ?z . } #	=> { ?y owl:sameAs ?z . } .# Inverse Functional Properties#{ ?pred a owl:InverseFunctionalProperty . } #	=> { ?pred a owl:Property . } .#{ ?pred a owl:InverseFunctionalProperty . ?x ?pred ?y . ?z ?pred ?y . } #	=> { ?x owl:sameAs ?z . } .#end